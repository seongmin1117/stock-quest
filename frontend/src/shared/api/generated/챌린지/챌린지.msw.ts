/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * StockQuest API
 * Î™®Ïùò Ìà¨Ïûê Ï±åÎ¶∞ÏßÄ ÌïôÏäµ ÌîåÎû´Ìèº API
 * OpenAPI spec version: 1.0.0
 */
import { faker } from "@faker-js/faker";
import { HttpResponse, delay, http } from "msw";
import type {
  ChallengeInstrumentResponse,
  ChallengeSessionResponse,
  GetApiChallenges200,
} from ".././model";

export const getGetApiChallengesResponseMock = (
  overrideResponse: Partial<GetApiChallenges200> = {},
): GetApiChallenges200 => ({
  content: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      createdAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
      description: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      id: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      periodEnd: faker.helpers.arrayElement([
        faker.date.past().toISOString().split("T")[0],
        undefined,
      ]),
      periodStart: faker.helpers.arrayElement([
        faker.date.past().toISOString().split("T")[0],
        undefined,
      ]),
      speedFactor: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      status: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["DRAFT", "ACTIVE", "COMPLETED"] as const),
        undefined,
      ]),
      title: faker.helpers.arrayElement([faker.word.sample(), undefined]),
    })),
    undefined,
  ]),
  totalElements: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  totalPages: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostApiChallengesChallengeIdStartResponseMock = (
  overrideResponse: Partial<ChallengeSessionResponse> = {},
): ChallengeSessionResponse => ({
  challengeId: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  currentBalance: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  id: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  seedBalance: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  startedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    undefined,
  ]),
  status: faker.helpers.arrayElement([
    faker.helpers.arrayElement(["READY", "ACTIVE", "ENDED"] as const),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetApiChallengesChallengeIdInstrumentsResponseMock =
  (): ChallengeInstrumentResponse[] =>
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      hiddenName: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      instrumentKey: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      type: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["STOCK", "DEPOSIT", "BOND"] as const),
        undefined,
      ]),
    }));

export const getGetApiChallengesMockHandler = (
  overrideResponse?:
    | GetApiChallenges200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetApiChallenges200> | GetApiChallenges200),
) => {
  return http.get("*/api/challenges", async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetApiChallengesResponseMock(),
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  });
};

export const getPostApiChallengesChallengeIdStartMockHandler = (
  overrideResponse?:
    | ChallengeSessionResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<ChallengeSessionResponse> | ChallengeSessionResponse),
) => {
  return http.post("*/api/challenges/:challengeId/start", async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getPostApiChallengesChallengeIdStartResponseMock(),
      ),
      {
        status: 201,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  });
};

export const getGetApiChallengesChallengeIdInstrumentsMockHandler = (
  overrideResponse?:
    | ChallengeInstrumentResponse[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) =>
        | Promise<ChallengeInstrumentResponse[]>
        | ChallengeInstrumentResponse[]),
) => {
  return http.get("*/api/challenges/:challengeId/instruments", async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetApiChallengesChallengeIdInstrumentsResponseMock(),
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  });
};
export const getMock = () => [
  getGetApiChallengesMockHandler(),
  getPostApiChallengesChallengeIdStartMockHandler(),
  getGetApiChallengesChallengeIdInstrumentsMockHandler(),
];
