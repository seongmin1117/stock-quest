/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * StockQuest API
 * Stock Trading Simulation Platform API
 * OpenAPI spec version: 1.0.0
 */
import { faker } from "@faker-js/faker";
import { HttpResponse, delay, http } from "msw";
import type {
  ActiveSignalsResponse,
  BatchSignalResponse,
  FilteredSignalResponse,
  PerformanceUpdateResponse,
  TradingSignalResponse,
} from ".././model";

export const getGetApiV1MlSignalsGenerateSymbolResponseMock = (
  overrideResponse: Partial<TradingSignalResponse> = {},
): TradingSignalResponse => ({
  confidence: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  expectedReturn: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  expectedRisk: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  expiresAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    undefined,
  ]),
  generatedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    undefined,
  ]),
  marketCondition: faker.helpers.arrayElement([
    {
      liquidity: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"] as const),
        undefined,
      ]),
      marketSentiment: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      regime: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "BULL",
          "BEAR",
          "SIDEWAYS",
          "VOLATILE",
        ] as const),
        undefined,
      ]),
      vixLevel: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      volatility: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"] as const),
        undefined,
      ]),
    },
    undefined,
  ]),
  signalId: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  signalType: faker.helpers.arrayElement([
    faker.helpers.arrayElement(["BUY", "SELL", "HOLD"] as const),
    undefined,
  ]),
  status: faker.helpers.arrayElement([
    faker.helpers.arrayElement(["ACTIVE", "EXPIRED", "TRIGGERED"] as const),
    undefined,
  ]),
  stopLossPrice: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  strength: faker.helpers.arrayElement([
    faker.helpers.arrayElement(["WEAK", "MODERATE", "STRONG"] as const),
    undefined,
  ]),
  symbol: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  targetPrice: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  timeHorizon: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  topReasons: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      category: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "TECHNICAL",
          "FUNDAMENTAL",
          "SENTIMENT",
        ] as const),
        undefined,
      ]),
      description: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      featureName: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      importance: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      value: faker.helpers.arrayElement([faker.word.sample(), undefined]),
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostApiV1MlSignalsGenerateBatchResponseMock = (
  overrideResponse: Partial<BatchSignalResponse> = {},
): BatchSignalResponse => ({
  signals: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      confidence: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      expectedReturn: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      expectedRisk: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      expiresAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
      generatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
      marketCondition: faker.helpers.arrayElement([
        {
          liquidity: faker.helpers.arrayElement([
            faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"] as const),
            undefined,
          ]),
          marketSentiment: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          regime: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              "BULL",
              "BEAR",
              "SIDEWAYS",
              "VOLATILE",
            ] as const),
            undefined,
          ]),
          vixLevel: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          volatility: faker.helpers.arrayElement([
            faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"] as const),
            undefined,
          ]),
        },
        undefined,
      ]),
      signalId: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      signalType: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["BUY", "SELL", "HOLD"] as const),
        undefined,
      ]),
      status: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["ACTIVE", "EXPIRED", "TRIGGERED"] as const),
        undefined,
      ]),
      stopLossPrice: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      strength: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["WEAK", "MODERATE", "STRONG"] as const),
        undefined,
      ]),
      symbol: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      targetPrice: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      timeHorizon: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      topReasons: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          category: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              "TECHNICAL",
              "FUNDAMENTAL",
              "SENTIMENT",
            ] as const),
            undefined,
          ]),
          description: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          featureName: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          importance: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          value: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        })),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostApiV1MlSignalsFilterResponseMock = (
  overrideResponse: Partial<FilteredSignalResponse> = {},
): FilteredSignalResponse => ({
  filteredCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  filteredSignals: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      confidence: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      expectedReturn: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      expectedRisk: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      expiresAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
      generatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
      marketCondition: faker.helpers.arrayElement([
        {
          liquidity: faker.helpers.arrayElement([
            faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"] as const),
            undefined,
          ]),
          marketSentiment: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          regime: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              "BULL",
              "BEAR",
              "SIDEWAYS",
              "VOLATILE",
            ] as const),
            undefined,
          ]),
          vixLevel: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          volatility: faker.helpers.arrayElement([
            faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"] as const),
            undefined,
          ]),
        },
        undefined,
      ]),
      signalId: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      signalType: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["BUY", "SELL", "HOLD"] as const),
        undefined,
      ]),
      status: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["ACTIVE", "EXPIRED", "TRIGGERED"] as const),
        undefined,
      ]),
      stopLossPrice: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      strength: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["WEAK", "MODERATE", "STRONG"] as const),
        undefined,
      ]),
      symbol: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      targetPrice: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      timeHorizon: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      topReasons: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          category: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              "TECHNICAL",
              "FUNDAMENTAL",
              "SENTIMENT",
            ] as const),
            undefined,
          ]),
          description: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          featureName: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          importance: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          value: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        })),
        undefined,
      ]),
    })),
    undefined,
  ]),
  marketRegime: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "BULL",
      "BEAR",
      "SIDEWAYS",
      "VOLATILE",
    ] as const),
    undefined,
  ]),
  totalOriginalCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPutApiV1MlSignalsSignalIdPerformanceResponseMock = (
  overrideResponse: Partial<PerformanceUpdateResponse> = {},
): PerformanceUpdateResponse => ({
  message: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  signalId: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  updated: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  ...overrideResponse,
});

export const getGetApiV1MlSignalsActiveResponseMock = (
  overrideResponse: Partial<ActiveSignalsResponse> = {},
): ActiveSignalsResponse => ({
  activeSignals: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      confidence: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      expectedReturn: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      expectedRisk: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      expiresAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
      generatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
      marketCondition: faker.helpers.arrayElement([
        {
          liquidity: faker.helpers.arrayElement([
            faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"] as const),
            undefined,
          ]),
          marketSentiment: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          regime: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              "BULL",
              "BEAR",
              "SIDEWAYS",
              "VOLATILE",
            ] as const),
            undefined,
          ]),
          vixLevel: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          volatility: faker.helpers.arrayElement([
            faker.helpers.arrayElement(["LOW", "MEDIUM", "HIGH"] as const),
            undefined,
          ]),
        },
        undefined,
      ]),
      signalId: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      signalType: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["BUY", "SELL", "HOLD"] as const),
        undefined,
      ]),
      status: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["ACTIVE", "EXPIRED", "TRIGGERED"] as const),
        undefined,
      ]),
      stopLossPrice: faker.helpers.arrayElement([
        faker.word.sample(),
        undefined,
      ]),
      strength: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["WEAK", "MODERATE", "STRONG"] as const),
        undefined,
      ]),
      symbol: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      targetPrice: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      timeHorizon: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      topReasons: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          category: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              "TECHNICAL",
              "FUNDAMENTAL",
              "SENTIMENT",
            ] as const),
            undefined,
          ]),
          description: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          featureName: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          importance: faker.helpers.arrayElement([
            faker.word.sample(),
            undefined,
          ]),
          value: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        })),
        undefined,
      ]),
    })),
    undefined,
  ]),
  count: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetApiV1MlSignalsGenerateSymbolMockHandler = (
  overrideResponse?:
    | TradingSignalResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<TradingSignalResponse> | TradingSignalResponse),
) => {
  return http.get("*/api/v1/ml/signals/generate/:symbol", async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetApiV1MlSignalsGenerateSymbolResponseMock(),
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  });
};

export const getPostApiV1MlSignalsGenerateBatchMockHandler = (
  overrideResponse?:
    | BatchSignalResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<BatchSignalResponse> | BatchSignalResponse),
) => {
  return http.post("*/api/v1/ml/signals/generate/batch", async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getPostApiV1MlSignalsGenerateBatchResponseMock(),
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  });
};

export const getPostApiV1MlSignalsFilterMockHandler = (
  overrideResponse?:
    | FilteredSignalResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<FilteredSignalResponse> | FilteredSignalResponse),
) => {
  return http.post("*/api/v1/ml/signals/filter", async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getPostApiV1MlSignalsFilterResponseMock(),
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  });
};

export const getPutApiV1MlSignalsSignalIdPerformanceMockHandler = (
  overrideResponse?:
    | PerformanceUpdateResponse
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<PerformanceUpdateResponse> | PerformanceUpdateResponse),
) => {
  return http.put("*/api/v1/ml/signals/:signalId/performance", async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getPutApiV1MlSignalsSignalIdPerformanceResponseMock(),
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  });
};

export const getGetApiV1MlSignalsActiveMockHandler = (
  overrideResponse?:
    | ActiveSignalsResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<ActiveSignalsResponse> | ActiveSignalsResponse),
) => {
  return http.get("*/api/v1/ml/signals/active", async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetApiV1MlSignalsActiveResponseMock(),
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  });
};
export const getMlMock = () => [
  getGetApiV1MlSignalsGenerateSymbolMockHandler(),
  getPostApiV1MlSignalsGenerateBatchMockHandler(),
  getPostApiV1MlSignalsFilterMockHandler(),
  getPutApiV1MlSignalsSignalIdPerformanceMockHandler(),
  getGetApiV1MlSignalsActiveMockHandler(),
];
