/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * StockQuest API
 * Stock Trading Simulation Platform API
 * OpenAPI spec version: 1.0.0
 */
import { faker } from "@faker-js/faker";
import { HttpResponse, delay, http } from "msw";
import type {
  BacktestResponse,
  EfficientFrontierResponse,
  OptimizationHistoryResponse,
  PortfolioOptimizationResponse,
  RebalancingSuggestionsResponse,
} from ".././model";

export const getPostApiV1MlPortfolioOptimizationPortfolioIdOptimizeResponseMock =
  (
    overrideResponse: Partial<PortfolioOptimizationResponse> = {},
  ): PortfolioOptimizationResponse => ({
    confidence: faker.helpers.arrayElement([faker.word.sample(), undefined]),
    currentAllocations: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        allocationConfidence: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        assetName: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        category: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        currentWeight: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        expectedReturn: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        expectedVolatility: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        recommendedWeight: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        riskContribution: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        symbol: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      })),
      undefined,
    ]),
    expectedPerformance: faker.helpers.arrayElement([
      {
        beta: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        expectedMaxDrawdown: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        expectedReturn: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        expectedSharpeRatio: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        expectedVolatility: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        trackingError: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
      },
      undefined,
    ]),
    generatedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      undefined,
    ]),
    nextRebalancingDate: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      undefined,
    ]),
    objective: faker.helpers.arrayElement([faker.word.sample(), undefined]),
    optimizationId: faker.helpers.arrayElement([
      faker.word.sample(),
      undefined,
    ]),
    optimizationType: faker.helpers.arrayElement([
      faker.word.sample(),
      undefined,
    ]),
    portfolioId: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    rebalancingActions: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        actionType: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["BUY", "SELL", "HOLD"] as const),
          undefined,
        ]),
        amount: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        estimatedCost: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        marketImpact: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        priority: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        quantity: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        reason: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        recommendedExecutionTime: faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split(".")[0]}Z`,
          undefined,
        ]),
        symbol: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      })),
      undefined,
    ]),
    recommendedAllocations: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        allocationConfidence: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        assetName: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        category: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        currentWeight: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        expectedReturn: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        expectedVolatility: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        recommendedWeight: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        riskContribution: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        symbol: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      })),
      undefined,
    ]),
    riskMetrics: faker.helpers.arrayElement([
      {
        concentrationRisk: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        cvar95: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        diversificationRatio: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        liquidityRisk: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        var95: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      },
      undefined,
    ]),
    ...overrideResponse,
  });

export const getPostApiV1MlPortfolioOptimizationPortfolioIdEfficientFrontierResponseMock =
  (
    overrideResponse: Partial<EfficientFrontierResponse> = {},
  ): EfficientFrontierResponse => ({
    frontierPoints: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        return: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        risk: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        sharpeRatio: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
      })),
      undefined,
    ]),
    portfolioId: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    ...overrideResponse,
  });

export const getGetApiV1MlPortfolioOptimizationPortfolioIdRebalancingSuggestionsResponseMock =
  (
    overrideResponse: Partial<RebalancingSuggestionsResponse> = {},
  ): RebalancingSuggestionsResponse => ({
    portfolioId: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    suggestions: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        actionType: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["BUY", "SELL", "HOLD"] as const),
          undefined,
        ]),
        amount: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        estimatedCost: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        marketImpact: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        priority: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        quantity: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        reason: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        recommendedExecutionTime: faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split(".")[0]}Z`,
          undefined,
        ]),
        symbol: faker.helpers.arrayElement([faker.word.sample(), undefined]),
      })),
      undefined,
    ]),
    totalSuggestions: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    ...overrideResponse,
  });

export const getGetApiV1MlPortfolioOptimizationPortfolioIdHistoryResponseMock =
  (
    overrideResponse: Partial<OptimizationHistoryResponse> = {},
  ): OptimizationHistoryResponse => ({
    optimizations: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        confidence: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        currentAllocations: faker.helpers.arrayElement([
          Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => ({
            allocationConfidence: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            assetName: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            category: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            currentWeight: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            expectedReturn: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            expectedVolatility: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            recommendedWeight: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            riskContribution: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            symbol: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
          })),
          undefined,
        ]),
        expectedPerformance: faker.helpers.arrayElement([
          {
            beta: faker.helpers.arrayElement([faker.word.sample(), undefined]),
            expectedMaxDrawdown: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            expectedReturn: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            expectedSharpeRatio: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            expectedVolatility: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            trackingError: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
          },
          undefined,
        ]),
        generatedAt: faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split(".")[0]}Z`,
          undefined,
        ]),
        nextRebalancingDate: faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split(".")[0]}Z`,
          undefined,
        ]),
        objective: faker.helpers.arrayElement([faker.word.sample(), undefined]),
        optimizationId: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        optimizationType: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        portfolioId: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        rebalancingActions: faker.helpers.arrayElement([
          Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => ({
            actionType: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["BUY", "SELL", "HOLD"] as const),
              undefined,
            ]),
            amount: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            estimatedCost: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            marketImpact: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            priority: faker.helpers.arrayElement([
              faker.number.int({ min: undefined, max: undefined }),
              undefined,
            ]),
            quantity: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            reason: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            recommendedExecutionTime: faker.helpers.arrayElement([
              `${faker.date.past().toISOString().split(".")[0]}Z`,
              undefined,
            ]),
            symbol: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
          })),
          undefined,
        ]),
        recommendedAllocations: faker.helpers.arrayElement([
          Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => ({
            allocationConfidence: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            assetName: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            category: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            currentWeight: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            expectedReturn: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            expectedVolatility: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            recommendedWeight: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            riskContribution: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            symbol: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
          })),
          undefined,
        ]),
        riskMetrics: faker.helpers.arrayElement([
          {
            concentrationRisk: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            cvar95: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            diversificationRatio: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            liquidityRisk: faker.helpers.arrayElement([
              faker.word.sample(),
              undefined,
            ]),
            var95: faker.helpers.arrayElement([faker.word.sample(), undefined]),
          },
          undefined,
        ]),
      })),
      undefined,
    ]),
    portfolioId: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    totalCount: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    ...overrideResponse,
  });

export const getPostApiV1MlPortfolioOptimizationPortfolioIdBacktestResponseMock =
  (overrideResponse: Partial<BacktestResponse> = {}): BacktestResponse => ({
    endDate: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      undefined,
    ]),
    maxDrawdown: faker.helpers.arrayElement([faker.word.sample(), undefined]),
    performanceData: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        benchmarkValue: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        cumulativeReturn: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
        date: faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split(".")[0]}Z`,
          undefined,
        ]),
        portfolioValue: faker.helpers.arrayElement([
          faker.word.sample(),
          undefined,
        ]),
      })),
      undefined,
    ]),
    portfolioId: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    sharpeRatio: faker.helpers.arrayElement([faker.word.sample(), undefined]),
    startDate: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      undefined,
    ]),
    totalReturn: faker.helpers.arrayElement([faker.word.sample(), undefined]),
    volatility: faker.helpers.arrayElement([faker.word.sample(), undefined]),
    ...overrideResponse,
  });

export const getPostApiV1MlPortfolioOptimizationPortfolioIdOptimizeMockHandler =
  (
    overrideResponse?:
      | PortfolioOptimizationResponse
      | ((
          info: Parameters<Parameters<typeof http.post>[1]>[0],
        ) =>
          | Promise<PortfolioOptimizationResponse>
          | PortfolioOptimizationResponse),
  ) => {
    return http.post(
      "*/api/v1/ml/portfolio-optimization/:portfolioId/optimize",
      async (info) => {
        await delay(1000);
        return new HttpResponse(
          JSON.stringify(
            overrideResponse !== undefined
              ? typeof overrideResponse === "function"
                ? await overrideResponse(info)
                : overrideResponse
              : getPostApiV1MlPortfolioOptimizationPortfolioIdOptimizeResponseMock(),
          ),
          {
            status: 200,
            headers: {
              "Content-Type": "application/json",
            },
          },
        );
      },
    );
  };

export const getPostApiV1MlPortfolioOptimizationPortfolioIdEfficientFrontierMockHandler =
  (
    overrideResponse?:
      | EfficientFrontierResponse
      | ((
          info: Parameters<Parameters<typeof http.post>[1]>[0],
        ) => Promise<EfficientFrontierResponse> | EfficientFrontierResponse),
  ) => {
    return http.post(
      "*/api/v1/ml/portfolio-optimization/:portfolioId/efficient-frontier",
      async (info) => {
        await delay(1000);
        return new HttpResponse(
          JSON.stringify(
            overrideResponse !== undefined
              ? typeof overrideResponse === "function"
                ? await overrideResponse(info)
                : overrideResponse
              : getPostApiV1MlPortfolioOptimizationPortfolioIdEfficientFrontierResponseMock(),
          ),
          {
            status: 200,
            headers: {
              "Content-Type": "application/json",
            },
          },
        );
      },
    );
  };

export const getGetApiV1MlPortfolioOptimizationPortfolioIdRebalancingSuggestionsMockHandler =
  (
    overrideResponse?:
      | RebalancingSuggestionsResponse
      | ((
          info: Parameters<Parameters<typeof http.get>[1]>[0],
        ) =>
          | Promise<RebalancingSuggestionsResponse>
          | RebalancingSuggestionsResponse),
  ) => {
    return http.get(
      "*/api/v1/ml/portfolio-optimization/:portfolioId/rebalancing-suggestions",
      async (info) => {
        await delay(1000);
        return new HttpResponse(
          JSON.stringify(
            overrideResponse !== undefined
              ? typeof overrideResponse === "function"
                ? await overrideResponse(info)
                : overrideResponse
              : getGetApiV1MlPortfolioOptimizationPortfolioIdRebalancingSuggestionsResponseMock(),
          ),
          {
            status: 200,
            headers: {
              "Content-Type": "application/json",
            },
          },
        );
      },
    );
  };

export const getGetApiV1MlPortfolioOptimizationPortfolioIdHistoryMockHandler = (
  overrideResponse?:
    | OptimizationHistoryResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<OptimizationHistoryResponse> | OptimizationHistoryResponse),
) => {
  return http.get(
    "*/api/v1/ml/portfolio-optimization/:portfolioId/history",
    async (info) => {
      await delay(1000);
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetApiV1MlPortfolioOptimizationPortfolioIdHistoryResponseMock(),
        ),
        {
          status: 200,
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
    },
  );
};

export const getPostApiV1MlPortfolioOptimizationPortfolioIdBacktestMockHandler =
  (
    overrideResponse?:
      | BacktestResponse
      | ((
          info: Parameters<Parameters<typeof http.post>[1]>[0],
        ) => Promise<BacktestResponse> | BacktestResponse),
  ) => {
    return http.post(
      "*/api/v1/ml/portfolio-optimization/:portfolioId/backtest",
      async (info) => {
        await delay(1000);
        return new HttpResponse(
          JSON.stringify(
            overrideResponse !== undefined
              ? typeof overrideResponse === "function"
                ? await overrideResponse(info)
                : overrideResponse
              : getPostApiV1MlPortfolioOptimizationPortfolioIdBacktestResponseMock(),
          ),
          {
            status: 200,
            headers: {
              "Content-Type": "application/json",
            },
          },
        );
      },
    );
  };
export const getMock = () => [
  getPostApiV1MlPortfolioOptimizationPortfolioIdOptimizeMockHandler(),
  getPostApiV1MlPortfolioOptimizationPortfolioIdEfficientFrontierMockHandler(),
  getGetApiV1MlPortfolioOptimizationPortfolioIdRebalancingSuggestionsMockHandler(),
  getGetApiV1MlPortfolioOptimizationPortfolioIdHistoryMockHandler(),
  getPostApiV1MlPortfolioOptimizationPortfolioIdBacktestMockHandler(),
];
